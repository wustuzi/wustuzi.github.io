<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法 高精度</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>我们这里所表示的高精度，大部分都是将大整数存储在数组中，来通过加减乘除基本运算法则，来对数组中的每一位数字来进行加减乘除，从而达到大整数加减乘除的目的。</p><h1 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h1><h2 id="一、高精度加法"><a href="#一、高精度加法" class="headerlink" title="一、高精度加法"></a>一、高精度加法</h2><p>输入：两个大整数     输出：大整数相加的结果</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector &lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&amp;#123;    if(A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i ++ )    &amp;#123;        t += A[i];        if(i &lt; B.size())    t += B[i];        C.push_back(t % 10);        t /= 10;     &amp;#125;    if(t)   C.push_back(t);    return C;&amp;#125;int main()&amp;#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for(int i = a.size() - 1; i &gt;= 0; i --)    A.push_back(a[i] - &#39;0&#39;);    for(int i = b.size() - 1; i &gt;= 0; i --)    B.push_back(b[i] - &#39;0&#39;);    auto C = add(A, B) ;    for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&amp;#125;</code></pre><p>本题同时通过vector容器，节省了空间</p><hr><h2 id="二、高精度减法"><a href="#二、高精度减法" class="headerlink" title="二、高精度减法"></a>二、高精度减法</h2><p>输入：两个大整数，大小顺序无要求    输出：第一个数减去第二个数</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&amp;#123;    if (A.size() != B.size()) return A.size() &gt; B.size();    for (int i = A.size() - 1; i &gt;= 0; i -- )        if (A[i] != B[i])            return A[i] &gt; B[i];    return true;&amp;#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&amp;#123;    vector&lt;int&gt; C;    for (int i = 0, t = 0; i &lt; A.size(); i ++ )    &amp;#123;        t = A[i] - t;        if (i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    &amp;#125;    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&amp;#125;int main()&amp;#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#39;0&#39;);    for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#39;0&#39;);    vector&lt;int&gt; C;    if (cmp(A, B)) C = sub(A, B);    else C = sub(B, A), cout &lt;&lt; &#39;-&#39;;    for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&amp;#125;</code></pre><p>本题的思路和大整数加法类似，唯一需要注意的是，当二者大小顺序相反时，即应当输出负数时，应该进行判断。 A-B &lt; 0, -(B-A)就是结果</p><hr><h2 id="三、高精度乘法"><a href="#三、高精度乘法" class="headerlink" title="三、高精度乘法"></a>三、高精度乘法</h2><p>输入：一个大整数和一个小整数    输出：两数相乘的结果</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&amp;#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i ++)    &amp;#123;        if(i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &amp;#125;    if(t != 0)   C.push_back(t);    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&amp;#125;int main()&amp;#123;    int b;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C = mul(A, b);    for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&amp;#125;</code></pre><p>开头用string存储大整数，用小整数来乘以大整数的每一位，然后根据所占的位数来进行进位。</p><hr><h2 id="四、高精度除法"><a href="#四、高精度除法" class="headerlink" title="四、高精度除法"></a>四、高精度除法</h2><p>输入：除数 被除数（不为0）    输出：除数除以被除数的结果</p><pre><code class="C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&amp;#123;    vector&lt;int&gt; C;    r = 0;    for(int i = A.size() - 1; i &gt;= 0; i --)    &amp;#123;        r = r * 10 + A[i];//借位        C.push_back(r / b);        r = r % b;    &amp;#125;    reverse(C.begin(), C.end());    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&amp;#125;int main()&amp;#123;    int b, r;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C = div(A, b, r);    for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;    return 0;&amp;#125;</code></pre><p>里面比较重要的是对于“借位”思想的代码操作，值得仔细琢磨</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练  归并排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>在学习了快排和归并排序的模板之后，快排在我们的题目中基本是不会出现的，出现的一般都是归并排序，在这里我记录几个训练过觉得比较有意义的归并排序的题目（题目均源自：洛谷）</p><hr><h1 id="归并排序题目"><a href="#归并排序题目" class="headerlink" title="归并排序题目"></a>归并排序题目</h1><h2 id="一、最接近神的人"><a href="#一、最接近神的人" class="headerlink" title="一、最接近神的人"></a>一、最接近神的人</h2><p><a href="https://www.luogu.com.cn/problem/P1774">原题链接</a></p><p>题解：</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;const int N = 500050;int q[N], p[N];long long sum;void sort(int q[], int l, int r)&amp;#123;    if(l &gt;= r)  return;    int mid = (l + r) / 2;    sort(q, l, mid), sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)    &amp;#123;        if(q[i] &lt;= q[j])        &amp;#123;            p[k ++] = q[i ++];        &amp;#125;        else        &amp;#123;            p[k ++] = q[j ++];            sum += mid - i + 1;//核心        &amp;#125;    &amp;#125;    while(i &lt;= mid) p[k ++] = q[i ++];    while(j &lt;= r)   p[k ++] = q[j ++];    for(i = l, j = 0; i &lt;= r; i ++, j ++)   q[i] = p[j];&amp;#125;int main()&amp;#123;    int n;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i];    sort(q, 0, n - 1);    cout &lt;&lt; sum;    return 0;&amp;#125;</code></pre><p>本题在归并排序的条件之下，进行了一些更为基本的调整，在进行大小顺序相反的交换时，会进行操作sum += mid - i + 1，这是本题的核心语句，仅当大小顺序相反时进行语句。</p><hr><h2 id="二、瑞士轮"><a href="#二、瑞士轮" class="headerlink" title="二、瑞士轮"></a>二、瑞士轮</h2><p><a href="https://www.luogu.com.cn/problem/P1309">原题链接</a></p><p>题解：</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;const int N = 200100;int p[N], q[N], a[N];//p存放能力值 q存放分数 a存放排名int w[N], l[N];//w数组存放赢的人的序号 l数组存放输的人的序号bool op(int x, int y)&amp;#123;    if(q[x] == q[y])    return x &lt; y;    return q[x] &gt; q[y];&amp;#125;int main()&amp;#123;    int n, r, t;    //2*n是总选手数目 r是比赛轮次 q是关注的排名    cin &gt;&gt; n &gt;&gt; r &gt;&gt; t;    n *= 2;    for(int i = 1; i &lt;= n; i ++)        &amp;#123;        a[i] = i;    &amp;#125;    for(int i = 1; i &lt;= n; i ++)        &amp;#123;        cin &gt;&gt; q[i];    &amp;#125;    for(int i = 1; i &lt;= n; i ++)        &amp;#123;        cin &gt;&gt; p[i] ;    &amp;#125;    sort(a + 1, a + n + 1, op);//先将分数进行排列    //a[1]-a[n] 的数值按照op进行排序    for(int i = 1; i &lt;= r; i ++)    &amp;#123;        int b = 0;        for(int j = 1; j &lt;= n; j += 2)        &amp;#123;            if(p[a[j]] &gt;= p[a[j + 1]])//根据能力值来判断胜负            &amp;#123;                q[a[j]] ++;                w[++ b] = a[j];                l[b] = a[j + 1];//记录胜者组记号和相对应的排名            &amp;#125;            else            &amp;#123;                q[a[j + 1]] ++;                w[++ b] = a[j + 1];                l[b] = a[j];            &amp;#125;        &amp;#125;        int x = 1, y = 1, k = 1;        while(x &lt;= b &amp;&amp; y &lt;= b)        &amp;#123;            if(op(w[x], l[y]))            &amp;#123;                a[k ++] = w[x ++];            &amp;#125;            else            &amp;#123;                a[k ++] = l[y ++];            &amp;#125;        &amp;#125;        while (x &lt;= b)        &amp;#123;            a[k ++] = w[x ++];        &amp;#125;        while (y &lt;= b)           &amp;#123;            a[k ++] = l[y ++];        &amp;#125;    &amp;#125;    cout &lt;&lt; a[t];    return 0;&amp;#125;</code></pre><p>这个题目需要开的数据比较多，但是题目里面的主体内容还是归并排序。只是在归并排序里面添加了两组，分为胜者组和败者组。</p><p>每组比赛的胜者：赛前，总分是按降序排的；获胜后都得1分，仍是降序；</p><p>每组比赛的负者：赛前，总分是按降序排的；不得分，仍是降序。</p><p>先按初始分数排序，然后按分数高低两人一组比赛；</p><p>胜者入队A，负者入队B。这样A、B自身仍是有序的；</p><p>只需进行合并操作即可，合并操作的复杂度是O(n),而如果用快排其复杂度为O(nlogn)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法  排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>虽然在C++里面有他自己所对应的sort函数，可以非常方便的来进行数组的排序，但是可以手写一个排序也是我们所必须要掌握的，这里介绍快速排序和归并排序两种排序</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>下面我们介绍两种排序方式</p><h2 id="一、快速排序"><a href="#一、快速排序" class="headerlink" title="一、快速排序"></a>一、快速排序</h2><pre><code class="C++">#include &lt;iostream&gt;using namespace std;const int N = 100010;int q[N];void quick_sort(int q[], int l, int r)&amp;#123;    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while (i &lt; j)    &amp;#123;        do i ++ ; while (q[i] &lt; x);//当找到比x小的停下        do j -- ; while (q[j] &gt; x);//当找到比x大的停下        if (i &lt; j) swap(q[i], q[j]);//两数交换    &amp;#125;    quick_sort(q, l, j);    quick_sort(q, j + 1, r);&amp;#125;int main()&amp;#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    quick_sort(q, 0, n - 1);    for (int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);    return 0;&amp;#125;</code></pre><p>本段代码通过多次将数组分为两份，来实现排序。</p><hr><h2 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h2><pre><code class="C++">#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], p[N];int n;void msort(int l, int r)&amp;#123;    if(l &gt;= r)  return;    int mid = (l + r) / 2;    msort(l, mid), msort(mid + 1, r);//分割成多个小的数组    int i = l, j = mid + 1, k = 1;    while(i &lt;= mid &amp;&amp; j &lt;= r)    &amp;#123;        if(q[i] &lt;= q[j])    p[k ++] = q[i ++];//比较大小        if(q[i] &gt; q[j])     p[k ++] = q[j ++];    &amp;#125;    while(i &lt;= mid) p[k ++] = q[i ++];//将没有塞进p数组的数字依次“丢进去”    while(j &lt;= r)   p[k ++] = q[j ++];    for(int i = l, j = 1; i &lt;= r;)  q[i ++] = p[j ++];&amp;#125;int main()&amp;#123;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i ++ )   cin &gt;&gt; q[i];    msort(1, n);    for(int i = 1; i &lt;= n; i ++ )   cout &lt;&lt; q[i] &lt;&lt; &#39; &#39;;    return 0;&amp;#125;</code></pre><p>先递归依次将数组分为多个小数组，然后对于每个小数组来进行比较操作，并用一个p数组来存储结果，最后将p数组的值赋值给q数组来达到排序的目的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在我们写博客的过程中，熟练掌握markdown语法，常常会使得自己的办事效率有事半功倍的效果，所以掌握markdown语法，是我们写博客的第一步，也是最基础重要的一步。</p><h1 id="Markdown快速入门（typora）"><a href="#Markdown快速入门（typora）" class="headerlink" title="Markdown快速入门（typora）"></a>Markdown快速入门（typora）</h1><h2 id="1-代码块："><a href="#1-代码块：" class="headerlink" title="1.代码块："></a>1.代码块：</h2><pre><code class="C++">// 用``` + 自己的语言再回车即可// C++ 代码块 ： ```C++ 以此类推</code></pre><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><pre><code class="C++"># 标题名称## 标题名称### 标题名称#### 标题名称##### 标题名称###### 标题名称从上到下 从一级标题到六级标题 从大到小</code></pre><h1 id="标题名称"><a href="#标题名称" class="headerlink" title="标题名称"></a>标题名称</h1><h2 id="标题名称-1"><a href="#标题名称-1" class="headerlink" title="标题名称"></a>标题名称</h2><h3 id="标题名称-2"><a href="#标题名称-2" class="headerlink" title="标题名称"></a>标题名称</h3><h4 id="标题名称-3"><a href="#标题名称-3" class="headerlink" title="标题名称"></a>标题名称</h4><h5 id="标题名称-4"><a href="#标题名称-4" class="headerlink" title="标题名称"></a>标题名称</h5><h6 id="标题名称-5"><a href="#标题名称-5" class="headerlink" title="标题名称"></a>标题名称</h6><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><pre><code class="C++">// 加粗**加粗语言**// 删除线~~删除线内容~~// 斜体*斜体内容*</code></pre><p><strong>加粗语言</strong></p><p><del>删除线内容</del></p><p><em>斜体内容</em></p><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><pre><code class="C++">// 引用语法&gt;作者：xxx&gt;&gt;作者：xxx&gt;&gt;&gt;作者：xxx</code></pre><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p></blockquote></blockquote></blockquote><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><pre><code class="C++">//分割线---//分割线2***</code></pre><hr><hr><h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><pre><code class="C++">//在线图片/本地图片！[图片的名字](地址) ----本地即为文件地址，在线即为右键图片链接（有网络)</code></pre><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7. 超链接"></a>7. 超链接</h2><pre><code class="C++">//超链接语法[名字](具体地址)</code></pre><p><a href="https://wustuzi.github.io/">我的github</a></p><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><pre><code class="C++">//无序列表- 目录一- 目录二//有序表格1 + 。 + 空格1.xxx2.xxx</code></pre><ul><li>目录一</li><li>目录二</li></ul><p>​    1.xxx</p><p>​    2.xxx</p><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>右键插入即可</p><table><thead><tr><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><pre><code class="？C++">按住ctrl + / 查看源码</code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/21/hello-world/"/>
      <url>/2020/08/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
