<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法 欧拉函数</title>
      <link href="/2020/10/31/%E7%AE%97%E6%B3%95-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2020/10/31/%E7%AE%97%E6%B3%95-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>欧拉函数的定义： 1<del>N中与N互质的数的个数（例如：6的欧拉函数是2，因为在1</del>6中，6 与  1和5 互质）<br>欧拉函数的快速求法： 一个数字N可以分解质因数为N = P1^α1 * P2^α2……Pk^αk，则一个数字的欧拉函数值为：N * （1 - 1/P1） * （1 - 1/P2）……（1 - 1/Pk）。（原理是容斥原理，需要了解的同学们可以去网上搜索一下，也可以直接背公式进行运用）</p><hr><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p><img src="https://img-blog.csdnimg.cn/20201031002232863.png" alt="欧拉函数"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int phi(int x)&#x2F;&#x2F;公式求欧拉函数&#123;    int ans &#x3D; x;  &#x2F;&#x2F;公式中第一个N    for(int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )&#x2F;&#x2F;循环里面去掉2~√x 的P1……Pk    &#123;        if(x % i &#x3D;&#x3D; 0)        &#123;            ans &#x3D; ans &#x2F; i * (i - 1);&#x2F;&#x2F;对于每一个Pk乘进结果里面            while(x % i &#x3D;&#x3D; 0)   x &#x2F;&#x3D; i;&#x2F;&#x2F;把Pk的倍数因子消去        &#125;    &#125;    if(x &gt; 1)   ans &#x3D; ans &#x2F; x * (x - 1);&#x2F;&#x2F;最后一个因数的判断    return ans;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while(n -- )    &#123;        int k;        cin &gt;&gt; k;        cout &lt;&lt; phi(k) &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是最基础的求欧拉函数的方法，通过公式来求。熟记模板即可。</p><hr><h1 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h1><p><img src="https://img-blog.csdnimg.cn/20201031004233877.png" alt="筛法求欧拉函数"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N &#x3D; 1000010;int p[N], cnt;&#x2F;&#x2F;存放质数int e[N];&#x2F;&#x2F;存放每一个点的欧拉函数值bool st[N];&#x2F;&#x2F;存放质数void get(int x)&#123;    e[1] &#x3D; 1;    for(int i &#x3D; 2; i &lt;&#x3D; x; i ++ )    &#123;        if(!st[i])        &#123;            p[cnt ++] &#x3D; i;            e[i] &#x3D; i - 1;&#x2F;&#x2F;如果i是质数，那么从1~i-1都与i互质        &#125;        for(int j &#x3D; 0; p[j] &lt;&#x3D; x &#x2F; i; j ++ )        &#123;            st[p[j] * i] &#x3D; true;&#x2F;&#x2F;记录该数字是合数            if(i % p[j] &#x3D;&#x3D; 0)&#x2F;&#x2F;p[j]是i 和 i * p[j]的最小质因子            &#123;                e[p[j] * i] &#x3D; e[i] * p[j];                break;            &#125;            e[p[j] * i] &#x3D; e[i] * (p[j] - 1);        &#125;    &#125;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    get(n);    LL ans;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   ans +&#x3D; e[i];    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个线性筛求欧拉函数里面比较难理解的是下面两个e[p[j] * i]的求法。</p><p>对于第一个e[p[j] * i]</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;e[i] &#x3D; i * (1 - 1&#x2F;p1) *……*(1 - 1&#x2F;pk)&#x2F;&#x2F;那么e[i*pj] &#x3D; pj * i * (1 - 1&#x2F;p1) *……*(1 - 1&#x2F;pk)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 对于第二个e[p[j] * i]</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;如果pj不是i的质因子，那么pj就是i*pj的最小质因子&#x2F;&#x2F;那么i*pj的质因子只比i的多一个pj&#x2F;&#x2F;所有euler[i*pj] &#x3D; pj*i*(1 - 1&#x2F;p1)*……*(1 - 1&#x2F;pk)*(1 - 1&#x2F;pj)&#x2F;&#x2F;               &#x3D; euler[i] * pj * (1 - 1&#x2F;pj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这两处理解清楚题目要求应该不大。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -基础算法 - C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 单链表与双链表</title>
      <link href="/2020/10/21/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/21/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>​        单链表在我们的算法题里面是很基础的一个东西，本节主要介绍几个链表的基本结构，为之后的双链表，以及一些需要用到单链表的地方进行基础学习。双链表对于单链表也只是多了一些东西罢了，基本的思想和结构还是和单链表十分相似的。</p><h1 id="单链表与双链表"><a href="#单链表与双链表" class="headerlink" title="单链表与双链表"></a>单链表与双链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="https://img-blog.csdnimg.cn/20201021083757575.png" alt="单链表"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int head, e[N], ne[N], idx;&#x2F;&#x2F;初始化void init()&#123;    head &#x3D; -1;    idx &#x3D; 0;&#125;&#x2F;&#x2F;插表头void he(int x)&#123;    e[idx] &#x3D; x, ne[idx] &#x3D; head, head &#x3D; idx ++;&#125;&#x2F;&#x2F;移除void re(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;&#x2F;&#x2F;添加void add(int k, int x)&#123;    e[idx] &#x3D; x; ne[idx] &#x3D; ne[k], ne[k] &#x3D; idx ++;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    init();    while(n --)    &#123;        char op;        int k, x;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &#39;H&#39;)        &#123;            cin &gt;&gt; x;            he(x);        &#125;        else if(op &#x3D;&#x3D; &#39;D&#39;)        &#123;            cin &gt;&gt; k;            if (!k) head &#x3D; ne[head];            else re(k - 1);        &#125;        else        &#123;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);        &#125;    &#125;    for(int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i])   cout &lt;&lt; e[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        本题主要介绍了单链表的基本结构以及对单链表进行初始化，插表头，移除，添加操作的具体细节，int head, e[N], ne[N], idx;是在链表结构里面最基本的东西，head表头，e数组存放数值，ne数组存放下一个数的位置，idx存放当前所存储到的位置，方便添加。</p><hr><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><img src="https://img-blog.csdnimg.cn/20201021084016918.png"></p><p><img src="https://img-blog.csdnimg.cn/20201021084030500.png" alt="双链表"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int e[N], l[N], r[N], idx;&#x2F;&#x2F;双指针用0作为节点，和1一起，构成初始的两个数&#x2F;&#x2F;在节点a右边插入void in(int a, int x)&#123;    e[idx] &#x3D; x;    l[idx] &#x3D; a, r[idx] &#x3D; r[a];    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;&#125;void re(int k)&#123;    l[r[k]] &#x3D; l[k];    r[l[k]] &#x3D; r[k];&#125;int main()&#123;    &#x2F;&#x2F;0是左端，1是右端    r[0] &#x3D; 1, l[1] &#x3D; 0, idx &#x3D; 2;    int n;    cin &gt;&gt; n;    while(n --)    &#123;        string op;        cin &gt;&gt; op;        int x, k;        if(op &#x3D;&#x3D; &quot;L&quot;)        &#123;            cin &gt;&gt; x;            in(0, x);        &#125;        else if(op &#x3D;&#x3D; &quot;R&quot;)        &#123;            cin &gt;&gt; x;            in(l[1], x);        &#125;        else if(op &#x3D;&#x3D; &quot;D&quot;)        &#123;            cin &gt;&gt; k;            re(k + 1);        &#125;        else if (op &#x3D;&#x3D; &quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            in(l[k + 1], x);        &#125;        else        &#123;            cin &gt;&gt; k &gt;&gt; x;            in(k + 1, x);        &#125;    &#125;    for (int i &#x3D; r[0]; i !&#x3D; 1; i &#x3D; r[i]) cout &lt;&lt; e[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        本项只写了两个函数，插入函数in和移除函数re，然后通过题目中不同的五种要求改变in或者re的位置，就可以达到目的，双链表结构的主要难点就是在于对于链表两端的处理。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练 离散化与区间合并</title>
      <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%A6%BB%E6%95%A3%E5%8C%96%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2020/09/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E7%A6%BB%E6%95%A3%E5%8C%96%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>离散化与区间合并属于一系列特殊的哈希方式，主要作用是将一个很长的数组对应到相邻的位置上面 区间合并可以快速解决一些特定的问题。</p><h2 id="火烧赤壁"><a href="#火烧赤壁" class="headerlink" title="火烧赤壁"></a>火烧赤壁</h2><p><img src="https://img-blog.csdnimg.cn/20200924151014179.png" alt="火烧赤壁"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 40100, M &#x3D; 20100;int a[M], b[M];&#x2F;&#x2F; a存放起点 b存放终点int k;long n &#x3D; 1, m &#x3D; 1, ans;long c[N];bool flag[40100];inline long find(long key)&#x2F;&#x2F;找原来位置&#123;    for(int i &#x3D; 1;i &lt;&#x3D; m; i ++ )    &#123;        if(c[i] &#x3D;&#x3D; key)        return i;    &#125;&#125;int main()&#123;    cin &gt;&gt; k;    for(int i &#x3D; 1; i &lt;&#x3D; k; i ++ )    &#123;        cin &gt;&gt; a[i];        cin &gt;&gt; b[i];        c[m] &#x3D; a[i];        m ++;        c[m] &#x3D; b[i];        m ++;    &#125;    sort(c + 1, c + m);    for(int i &#x3D; 1;i &lt;&#x3D; k; i ++ )    &#123;        a[i] &#x3D; find(a[i]);        b[i] &#x3D; find(b[i]) - 1;&#x2F;&#x2F;找原位置        for(int j &#x3D; a[i]; j &lt;&#x3D; b[i]; j ++ )        flag[j] &#x3D; true;&#x2F;&#x2F;为有效    &#125;    for(long i&#x3D;1;i&lt;&#x3D;m;++i)    &#123;        if(flag[i])        ans +&#x3D; c[i + 1]-c[i];&#x2F;&#x2F;有效，加入ans    &#125;    cout &lt;&lt; ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 离散化与区间合并</title>
      <link href="/2020/09/13/%E7%AE%97%E6%B3%95-%E7%A6%BB%E6%95%A3%E5%8C%96%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2020/09/13/%E7%AE%97%E6%B3%95-%E7%A6%BB%E6%95%A3%E5%8C%96%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>离散化是一种很特殊的哈希方式，将一个较大区间的数字按照一定的规律进行缩小，从而达到方便1快速访问和查找的效果；区间合并，顾名思义，就是把有重复部分的区间合并成为一个区间，避免访问中的重复询问。</p><h1 id="离散化与区间合并"><a href="#离散化与区间合并" class="headerlink" title="离散化与区间合并"></a>离散化与区间合并</h1><h2 id="一、离散化"><a href="#一、离散化" class="headerlink" title="一、离散化"></a>一、离散化</h2><p><img src="https://img-blog.csdnimg.cn/20200913112937545.png" alt="离散化"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 位运算</title>
      <link href="/2020/09/08/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/08/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>位运算在某些特定的题目里面会有涉及，可以在较快的时间内求解一些特殊的问题，比如求1或者0，在二进制里面有非常特殊的运用。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="一、二进制中1的个数"><a href="#一、二进制中1的个数" class="headerlink" title="一、二进制中1的个数"></a>一、二进制中1的个数</h2><p><img src="https://img-blog.csdnimg.cn/20200908230522849.png" alt="二进制中1的个数"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int a[N];int main()&#123;    int m;    cin &gt;&gt; m;    while(m --)    &#123;        int x, sum &#x3D; 0;        cin &gt;&gt; x;        for(int i &#x3D; x; i; i -&#x3D; i &amp; -i)  sum ++;        cout &lt;&lt; sum &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lobit函数的运用是位运算里面最本质的地方</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int lowbit(int x) &#123;    return x &amp; (-x);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要把lobit函数的本质弄清楚，位运算的题目就可以理解。</p><hr><p>由于本主题题目较少，有水文章的嫌疑</p><p>但是没办法，我确实在水文章，后面几天多更新一点。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C ++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 双指针算法</title>
      <link href="/2020/09/07/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
      <url>/2020/09/07/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>双指针算法在我们平时的还很多例题里面都有涉及，比如归并排序里面，两个指针指向每一半的开头部分，通过对比大小向后移动。又比如在模拟栈里面，通过两个指针模拟栈的栈顶和栈底元素。也是属于一种双指针算法。</p><h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="一-最长连续不重复子序列"><a href="#一-最长连续不重复子序列" class="headerlink" title="一.最长连续不重复子序列"></a>一.最长连续不重复子序列</h2><p><img src="https://img-blog.csdnimg.cn/20200907110030862.png" alt="最长连续不重复子序列"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N], p[N];&#x2F;&#x2F;p用来存放出现数字的字数 q用来存放数组int n, res;&#x2F;&#x2F;res是答案int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    for(int l &#x3D; 1, r &#x3D; 1; r &lt;&#x3D; n; r ++)    &#123;        p[q[r]] ++;        while(l &lt; r &amp;&amp; p[q[r]] &gt; 1)    p[q[l ++]] --;        res &#x3D; max(res, r - l + 1);&#x2F;&#x2F;更新成最大值    &#125;    cout &lt;&lt; res;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过两个指针l， r的依次移动，对于每个扫过去的数字，存储进p数组内。然后通过对p数组出现数字次数的判断，来判断是否存在一个不重复序列。</p><hr><h2 id="二、数组元素的目标和"><a href="#二、数组元素的目标和" class="headerlink" title="二、数组元素的目标和"></a>二、数组元素的目标和</h2><p><img src="https://img-blog.csdnimg.cn/20200907110046646.png" alt="数组元素的目标和"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n, m, x;int a[N], b[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;    for(int i &#x3D; 0; i &lt; n; i ++ )    cin &gt;&gt; a[i];    for(int i &#x3D; 0; i &lt; m; i ++ )    cin &gt;&gt; b[i];    for(int i &#x3D; 0, j &#x3D; m - 1; i &lt; n; i ++)    &#123;        while(j &gt;&#x3D; 0 &amp;&amp; a[i] + b[j] &gt; x)    j --;        if(j &gt;&#x3D; 0 &amp;&amp; a[i] + b[j] &#x3D;&#x3D; x)  cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是双指针算法的第二种形式，主要类似于归并排序里面的思想，在两个数组里面依次移动，本题目做了一些优化，主要是将第二个数组从后往前，减小了出错的机率。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练 前缀和与差分</title>
      <link href="/2020/08/27/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2020/08/27/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>前缀和和差分问题在解决两类分别不同的问题时作用非常大，我们可以具体看几个例题，加深对于前缀和与差分的理解。</p><h1 id="前缀和与差分训练"><a href="#前缀和与差分训练" class="headerlink" title="前缀和与差分训练"></a>前缀和与差分训练</h1><h2 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1.前缀和"></a>1.前缀和</h2><h3 id="一、取石子"><a href="#一、取石子" class="headerlink" title="一、取石子"></a>一、取石子</h3><p><img src="https://img-blog.csdnimg.cn/20200826102242259.png" alt="取石子"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 110;int a[N];int n;long long sum, k;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        cin &gt;&gt; a[i];        sum +&#x3D; a[i];    &#125;    if(sum % 2) cout &lt;&lt; &quot;Alice&quot;;    else    cout &lt;&lt; &quot;Bob&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目只要理解了题意就会比较简单，因为无论如何石子最后的数量都会被取光，所以石子总个数的奇偶性就是答案的最根本依据。</p><p><a href="https://www.luogu.com.cn/problem/P4702">原题链接</a></p><hr><h3 id="二、连续自然数和"><a href="#二、连续自然数和" class="headerlink" title="二、连续自然数和"></a>二、连续自然数和</h3><p><img src="https://img-blog.csdnimg.cn/20200826102122622.png" alt="连续自然数和"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int m;const int N &#x3D; 2000010;int a[N];int main()&#123;    cin &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; N; i ++ )    &#123;        a[i] +&#x3D; a[i - 1] + i;    &#125;    for(int i &#x3D; 4, j &#x3D; 1; i &lt; m;)    &#123;        if(a[i] - a[j - 1] &lt; m) i ++;        else if(a[i] - a[j - 1] &gt; m) j ++;        else        &#123;            cout &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; i &lt;&lt; endl;            i ++;            j ++;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目主要的核心其实应该是双指针算法，但是最基本的要求也是在先有前缀和的条件基础上使用双指针算法，通过后面一个数字的前缀和减去前面一个数字的，从而达到快速求出某一段的具体值的效果。</p><p><a href="https://www.luogu.com.cn/problem/P1147">原题链接</a></p><hr><h3 id="三、Subsequences-Summing-to-Sevens-S"><a href="#三、Subsequences-Summing-to-Sevens-S" class="headerlink" title="三、Subsequences Summing to Sevens S"></a>三、Subsequences Summing to Sevens S</h3><p><img src="https://img-blog.csdnimg.cn/20200826102155554.png" alt="Subsequences Summing to Sevens S"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N];int l[7], r[7];int n, max1;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        cin &gt;&gt; q[i];        q[i] +&#x3D; q[i - 1];        q[i] %&#x3D; 7;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        if(l[q[i]] &#x3D;&#x3D; 0 )   l[q[i]] &#x3D; i;        if(r[q[i]] &#x3D;&#x3D; 0 )   r[q[i]] &#x3D; i;        else if(r[q[i]] &lt; i)    r[q[i]] &#x3D; i;    &#125;    for(int i &#x3D; 0; i &lt;&#x3D; 6; i ++ )    &#123;        if(r[i] - l[i] &gt;&#x3D; max1) max1 &#x3D; r[i] - l[i];    &#125;    cout &lt;&lt; max1;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目有个地方最关键，就是l和r数组，里面存储的是每一个数字对应的余数，易知，当余数为相同的时候，相减部分应当都能被被除数整除。</p><p><a href="https://www.luogu.com.cn/problem/P3131">原题链接</a></p><hr><h3 id="四、Programiranje"><a href="#四、Programiranje" class="headerlink" title="四、Programiranje"></a>四、Programiranje</h3><p><img src="https://img-blog.csdnimg.cn/20200826102526576.png"></p><p><img src="https://img-blog.csdnimg.cn/20200827133744512.png" alt="Programiranje"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 50010;int q[N][27];int main()&#123;    string str;    cin &gt;&gt; str;    int n &#x3D; str.size(), k, t, a, b, c, d, m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        k &#x3D; str[i - 1] - &#39;a&#39; + 1;        q[i][k] ++;        for(int j &#x3D; 1; j &lt;&#x3D; 26; j ++ )        &#123;            q[i][j] +&#x3D; q[i - 1][j];        &#125;    &#125;    cin &gt;&gt; m;    while(m --)    &#123;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;        for(int i &#x3D; 1; i &lt;&#x3D; 26; i ++ )        &#123;           if(q[b][i] - q[a - 1][i] &#x3D;&#x3D; q[d][i] - q[c - 1][i])           &#123;               t &#x3D; 1;           &#125;           else           &#123;               t &#x3D; 0;               break;           &#125;        &#125;        if(t)   cout &lt;&lt; &quot;DA&quot; &lt;&lt;endl;        else    cout &lt;&lt; &quot;NE&quot; &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题最终目的即为查看重复出现的字母，我的做法是开一个二维数组，来存放每一个出现的数字，同样的也可以通过求前缀和的方法来求解本题，但是需要注意的是，可以对每个相应的字母乘以一个无关的量，从而减小出错概率。</p><p><a href="https://www.luogu.com.cn/problem/P4440">原题链接</a></p><hr><h2 id="2-差分"><a href="#2-差分" class="headerlink" title="2.差分"></a>2.差分</h2><h3 id="一、海底高铁"><a href="#一、海底高铁" class="headerlink" title="一、海底高铁"></a>一、海底高铁</h3><p><img src="https://img-blog.csdnimg.cn/20200827134442693.png"></p><p><img src="https://img-blog.csdnimg.cn/20200827134455696.png" alt="海底高铁"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long L;const int N &#x3D; 100010;int a[N], b[N], c[N], p[N];&#x2F;&#x2F;p存放路径L ans, q[N];&#x2F;&#x2F;q 存放差分结果int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ )   cin &gt;&gt; p[i];    for(int i &#x3D; 1; i &lt; n; i ++ )    cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];    for(int i &#x3D; 1; i &lt; m; i ++ )&#x2F;&#x2F;形成差分    &#123;        if(p[i] &gt; p[i + 1])        &#123;            q[p[i + 1]] ++;            q[p[i]] --;        &#125;        else        &#123;            q[p[i + 1]] --;            q[p[i]] ++;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   q[i] +&#x3D; q[i - 1];    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        if(b[i] * q[i] + c[i] &gt;&#x3D; a[i] * q[i])        &#123;            ans +&#x3D; a[i] * q[i];        &#125;        else        &#123;            ans +&#x3D; b[i] * q[i] + c[i];        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以知道，到达了哪个城市，通过哪个路径，可以很清晰的通过该路径的差分矩阵来表示，然后再通过求差分矩阵的前缀和求出每一段路一共经过了多少次，最后判断是否买卡，从而求得最小的总花费。</p><p><a href="https://www.luogu.com.cn/problem/P3406">原题链接</a></p><h3 id="二、地毯"><a href="#二、地毯" class="headerlink" title="二、地毯"></a>二、地毯</h3><p><img src="https://img-blog.csdnimg.cn/20200827134518950.png"></p><p><img src="https://img-blog.csdnimg.cn/20200827134539335.png" alt="地毯"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int q[N][N], b[N][N];int n, m, x1, y1, x2, y2;void insert(int x1, int y1, int x2, int y2)&#123;    b[x1][y1] ++;    b[x2 + 1][y1] --;    b[x1][y2 + 1] --;    b[x2 + 1][y2 + 1] ++;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    while(m --)    &#123;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        insert(x1, y1, x2, y2);    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )        &#123;            b[i][j] +&#x3D; b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )        &#123;            cout &lt;&lt; b[i][j] &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显的二维差分数组的问题，对某一块地方盖上地毯，相当于对该部分里的每一个数据进行加一，也就是我们进行差分操作，最后求前缀和得到地板真正的形状。</p><p><a href="https://www.luogu.com.cn/problem/P3397">原题链接</a></p><hr><h3 id="三、cover"><a href="#三、cover" class="headerlink" title="三、cover"></a>三、cover</h3><p><img src="https://img-blog.csdnimg.cn/20200827134604408.png" alt="cover"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n, m, r, sum;bool a[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;    while(m -- )    &#123;        int x1, y1;        cin &gt;&gt; x1 &gt;&gt; y1;        a[x1][y1] &#x3D; 1;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            &#123;                if((x1 - i) * (x1 - i) + (y1 - j) * (y1 - j) &lt;&#x3D; r * r)  a[i][j] &#x3D; 1;            &#125;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )        &#123;            if(a[i][j]) sum ++;        &#125;    &#125;    cout &lt;&lt; sum;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最重要的一段就是中间判断该点内是否在搜索范围内，搜索的应该是直线距离。</p><p><a href="https://www.luogu.com.cn/problem/P3717">原题链接</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法  前缀和与差分</title>
      <link href="/2020/08/26/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2020/08/26/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>前缀和与差分问题在解决某一些特定问题的时候非常好用，比如在需要快速求解某一段区间内的总和时，只需要动用前缀和数组用a[n] - a[m]就可以快速求解，降低时间复杂度为o(1)。而差分是前缀和的一个逆运算，当需要给区间内每一个数字进行加减运算时，我们只需要对其差分数组进行几个数字的操作，再对其求前缀和即可。(题目源于ACwing，侵删)</p><h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><h2 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1.前缀和"></a>1.前缀和</h2><h3 id="一、一维前缀和"><a href="#一、一维前缀和" class="headerlink" title="一、一维前缀和"></a>一、一维前缀和</h3><p><img src="https://img-blog.csdnimg.cn/20200826130610110.png" alt="一维前缀和"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int a[N];int l, r, n, q;int main()&#123;    cin &gt;&gt; n &gt;&gt; q;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        cin &gt;&gt; a[i];        a[i] +&#x3D; a[i - 1];    &#125;    while(q -- )    &#123;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; a[r] - a[l - 1] &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路较为简单，简单介绍了一下前缀和的最基本应用。</p><hr><h3 id="二、二维前缀和-子矩阵的和"><a href="#二、二维前缀和-子矩阵的和" class="headerlink" title="二、二维前缀和(子矩阵的和)"></a>二、二维前缀和(子矩阵的和)</h3><p><img src="https://img-blog.csdnimg.cn/20200826130939800.png" alt="子矩阵的和"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int a[N][N];int n, m, q, x1, x2, y1, y2;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; m; j ++ )        &#123;            cin &gt;&gt; a[i][j];            a[i][j] +&#x3D; a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];        &#125;    &#125;    while(q -- )    &#123;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; a[x2][y2] - a[x1 - 1][y2] - a[x2][y1 - 1] + a[x1 - 1][y1 - 1] &lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个形式需要比较好的想象力，知道在什么时候应该减去或者加上哪个部分，并转换成相应的代数形式。</p><hr><h2 id="2-差分"><a href="#2-差分" class="headerlink" title="2.差分"></a>2.差分</h2><h3 id="一、差分"><a href="#一、差分" class="headerlink" title="一、差分"></a>一、差分</h3><p><img src="https://img-blog.csdnimg.cn/202008261312395.png" alt="差分"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int n, m, l, r, c;const int N &#x3D; 100010;int q[N], p[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];&#x2F;&#x2F;输入矩阵    while(m -- )    &#123;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;        p[l] +&#x3D; c;        p[r + 1] -&#x3D; c;&#x2F;&#x2F;转换成差分矩阵进行运算    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   p[i] +&#x3D; p[i - 1];&#x2F;&#x2F;差分矩阵的前缀和矩阵就是原来矩阵    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;           cout &lt;&lt; q[i] + p[i] &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过本题可以看出来差分，对于某一段的固定插入某一个数会显得很方便，只需要改变前面和后面一个即可。</p><hr><h3 id="二、差分矩阵"><a href="#二、差分矩阵" class="headerlink" title="二、差分矩阵"></a>二、差分矩阵</h3><p><img src="https://img-blog.csdnimg.cn/20200826131551227.png" alt="差分矩阵"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c)&#123;    b[x1][y1] +&#x3D; c;    b[x2 + 1][y1] -&#x3D; c;    b[x1][y2 + 1] -&#x3D; c;    b[x2 + 1][y2 + 1] +&#x3D; c;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )            scanf(&quot;%d&quot;, &amp;a[i][j]);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )            insert(i, j, i, j, a[i][j]);    while (q -- )    &#123;        int x1, y1, x2, y2, c;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;        insert(x1, y1, x2, y2, c);    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )            b[i][j] +&#x3D; b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) printf(&quot;%d &quot;, b[i][j]);        puts(&quot;&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>差分矩阵里面，insert函数是非常重要的一点，insert可以在差分矩阵中将我们所需要进行的操作进行转换，最后再求他的差分矩阵的前缀和即可。关于b函数的理解需要加深。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练 二分</title>
      <link href="/2020/08/25/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%BA%8C%E5%88%86/"/>
      <url>/2020/08/25/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>在基本掌握了二分的概念之后，如何在题目中，对应不同的题目，灵活使用，灵活改变while里面if的形式，是我们灵活解决二分题目的关键</p><h1 id="算法训练-二分"><a href="#算法训练-二分" class="headerlink" title="算法训练 二分"></a>算法训练 二分</h1><h2 id="一、砍树"><a href="#一、砍树" class="headerlink" title="一、砍树"></a>一、砍树</h2><p><img src="https://img-blog.csdnimg.cn/20200825214819393.png" alt="砍树"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1000010;int q[N];int n;long long m;bool check(int x)&#x2F;&#x2F;判断if里面的东西 在这个x答案的时候是否符合题目要求 以此来缩小区间&#123;    long long sum &#x3D; 0;    for(int i &#x3D; n; q[i] &gt; x &amp;&amp; i &gt;&#x3D; 1; i --)    sum +&#x3D; q[i] - x;    if(sum &gt;&#x3D; m) return true;    else return false;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    sort(q + 1, q + 1 + n);    int l &#x3D; 0, r &#x3D; q[n], mid;    while(l &lt; r)    &#123;        mid &#x3D; (l + r + 1) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    cout &lt;&lt; r;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题应该算是二分当中比较基础的一道题目，非常简单，我们二分的目标主要就是答案，我们需要砍树的高度就是我们需要去求得的结果，然而这个结果有一个区间，区间显然是0 ——这群树的最高高度。<br>然后通过二分答案区间组来快速求得答案。</p><p><a href="https://www.luogu.com.cn/problem/P1873">原题链接</a></p><hr><h2 id="二、数列分段-Section-II"><a href="#二、数列分段-Section-II" class="headerlink" title="二、数列分段 Section II"></a>二、数列分段 Section II</h2><p><img src="https://img-blog.csdnimg.cn/20200825214908401.png" alt="数列分段 Section II"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1000100;int m, n;int q[N];bool check(long long x)&#x2F;&#x2F;x的意思代表一组和最大为x&#123;    int s &#x3D; 0, num &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        if(s + q[i] &gt; x )           &#123;            num ++, s &#x3D; 0;        &#125;        s +&#x3D; q[i];        if(num &gt;&#x3D; m) return false;&#x2F;&#x2F;当组数超过题目条件时，失败    &#125;    return true;&#x2F;&#x2F;当运行到这里还没有return false时即表示该答案区间可以&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    long long sum &#x3D; 0, max &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        sum +&#x3D; q[i];        if(max &lt;&#x3D; q[i]) max &#x3D; q[i];    &#125;    long long l &#x3D; max, r &#x3D; sum, mid;&#x2F;&#x2F;最小的一组是最大的单个数，最大的是全部一组    while(l &lt; r)    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    cout &lt;&lt; l;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目很有意思，我们二分的是我们所需要的答案，但是我们需要将我们求得答案的区间进行压缩，右区间显然是全部数值相加的和，左区间应该是我们的全部数组中每个元素的最大值.然后通过二分求得该答案是否可行。二分的时候在check函数里面，我们可以定义一个数，来对每一个已经达到我们测试的值进行分装。</p><p><a href="https://www.luogu.com.cn/problem/P1182">原题链接</a></p><hr><h2 id="三、切绳子"><a href="#三、切绳子" class="headerlink" title="三、切绳子"></a>三、切绳子</h2><p><img src="https://img-blog.csdnimg.cn/20200825214928931.png" alt="切绳子"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;const int N &#x3D; 10010;int n, k;float q[N];bool check(float x)&#123;    int num &#x3D; 0;    float a;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        a &#x3D; q[i];         while(a - x &gt; 0)        &#123;            num ++;            a -&#x3D; x;        &#125;        if(num &gt;&#x3D; k)    return true;总长度大于等于所需长度    &#125;    return false;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    sort(q + 1, q + n + 1);    float l &#x3D; 0.01, r &#x3D; q[n], mid;    while(r - l &gt; 0.01)&#x2F;&#x2F;当所取区间小于一个数字时即停止    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else    r &#x3D; mid - 0.01;    &#125;    printf(&quot;%.2f&quot;, l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题需要灵活运用的地方很多，可以仔细理解。</p><hr><h2 id="四、进击的奶牛"><a href="#四、进击的奶牛" class="headerlink" title="四、进击的奶牛"></a>四、进击的奶牛</h2><p><img src="https://img-blog.csdnimg.cn/20200825214841822.png" alt="进击的奶牛"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int A[1000010];int a, n, c;bool check(int m)&#123;    int num &#x3D; 0;    int x &#x3D; A[1];&#x2F;&#x2F;第一只牛的储存位置    for(int i &#x3D; 2; i &lt;&#x3D; n; i ++)    &#123;        if(A[i] - x &lt; m)   num ++;        else    x &#x3D; A[i];&#x2F;&#x2F;变成“第一只牛”        if(num &gt; a) return false;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; c;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; A[i];    sort(A + 1, A + n + 1);    a &#x3D; n - c;    int l &#x3D; 1, r &#x3D; A[n] - A[1], mid;&#x2F;&#x2F;最小的时候距离为1 最大的时候只有两只牛    while(l + 1 &lt; r)    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else    r &#x3D; mid;    &#125;    if(check(r)) cout &lt;&lt; r;    else cout &lt;&lt; l;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目也是和之前的题目一样，通过筛选答案的区间，从而得到题解，这个题题目很巧妙，通过放牛进坑的方式来得到这道题最终的答案。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 二分</title>
      <link href="/2020/08/25/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"/>
      <url>/2020/08/25/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>二分是我们在解题时候常用的一种可以对有序的数列进行快速查找的一种方法，熟练灵活运用二分模板，可以在一些特定时候极大加快运行速度。</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a>一、查找</h2><p><img src="https://img-blog.csdnimg.cn/2020082512430149.png" alt="查找"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int n, m, p;int q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)    cin &gt;&gt; q[i];    while(m --)    &#123;        int l &#x3D; 1, r &#x3D; n;        cin &gt;&gt; p;        while(l + 1 &lt; r)        &#123;            int mid &#x3D; (l + r) &#x2F; 2;            if(q[mid] &lt; p) l &#x3D; mid + 1;            else    r &#x3D; mid;        &#125;        if(q[l] &#x3D;&#x3D; p)   cout &lt;&lt; l;        else if(q[r] &#x3D;&#x3D; p)  cout &lt;&lt; r;        else    cout &lt;&lt; &quot;-1&quot;;        cout &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目是一个很基本的二分题目，可见二分的基本模板应该是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(l + 1 &lt; r)&#123;      int mid &#x3D; (l + r) &#x2F; 2;    if(q[mid] &lt; p) l &#x3D; mid + 1;    else    r &#x3D; mid;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过while内部if的条件来更改所需要的区间而达到一次筛选一半的目的，当左右两区间相等时，所得到的最小区间即应该是我们所寻找的答案，当然如果这个区间里面也不含答案的话，则说明答案不存在。</p><hr><h2 id="二、一元三次方程的解"><a href="#二、一元三次方程的解" class="headerlink" title="二、一元三次方程的解"></a>二、一元三次方程的解</h2><p><img src="https://img-blog.csdnimg.cn/20200825125059362.png" alt="一元三次方程的解"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;float a, b, c, d, mid;float res(float x)&#x2F;&#x2F;&#123;    float q;    q &#x3D; a * x * x * x + b * x * x + c * x + d;    return q;&#125;int main()&#123;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;    for(float l &#x3D; -100; l &lt;&#x3D; 99; l ++)    &#123;        float r &#x3D; l + 1;        if(res(l) * res(r) &lt;&#x3D; 0)        &#123;            while(r - l &gt; 0.00001)            &#123;                mid &#x3D; (l + r) &#x2F; 2;                if(res(l) * res(mid) &gt; 0)  l &#x3D; mid;                else    r &#x3D; mid;            &#125;            if(res(mid) &lt; 0.1)            &#123;            printf(&quot;%.2f &quot;, mid);            &#125;         &#125;        else    continue;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题也应该算是比较经典的一道题目，我们需要通过二分定义答案区间，这个题需要注意的是二分时while循环的条件，while里面的条件是处理浮点数二分的不一样的地方。</p><hr><p>二分的基本概念就是把有序列答案区间进行中点的分割，根据某项性质求出答案存在的那一边，经过多次二分最终将答案所属区间确定为一个点。<br>二分较难的地方在于对于某些情况，mid = （l + r + 1）/ 2；<br>这里推荐一种比较好的办法，将二分的条件最后转化成while（l + 1 &lt; r）这样可以有效的避免死循环<br>但是需要注意的是<br>在下面输出结果的时候 必须要对l和r分别都进行答案检验。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练 高精度</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2020/08/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>高精度里面，最根本的就是学会用数组来存储数据，灵活运用数组，将可以很好的掌握所有类型的高精度题目</p><h1 id="算法训练-高精度"><a href="#算法训练-高精度" class="headerlink" title="算法训练 高精度"></a>算法训练 高精度</h1><h2 id="一、高精度乘法（两个大整数）"><a href="#一、高精度乘法（两个大整数）" class="headerlink" title="一、高精度乘法（两个大整数）"></a>一、高精度乘法（两个大整数）</h2><p><img src="https://img-blog.csdnimg.cn/20200824214321829.png" alt="高精度乘法"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10000010;int A[N], B[N], C[N];int main()&#123;    string a, b;    cin &gt;&gt; a &gt;&gt; b;    int x &#x3D; a.length(), y &#x3D; b.length();    for(int i &#x3D; x; i &gt; 0; i --) A[i] &#x3D; (a[x - i] - &#39;0&#39;);    for(int i &#x3D; y; i &gt; 0; i --) B[i] &#x3D; (b[y - i] - &#39;0&#39;);    for(int i &#x3D; 1; i &lt;&#x3D; x; i ++)    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; y; j ++)        &#123;            C[i + j - 1] +&#x3D; A[i] * B[j];        &#125;    &#125;    int l &#x3D; x + y;    int t &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; l; i ++)    &#123;        C[i] +&#x3D; t;        t &#x3D; C[i] &#x2F; 10;        C[i] %&#x3D; 10;    &#125;    int k;    while(C[l] &#x3D;&#x3D; 0 &amp;&amp; l &gt; 1) l --;    for(int i &#x3D; l; l &gt; 0; l --)    cout &lt;&lt; C[l];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乘法题目需要注意的是每几位相乘的结果所在的位，比如个位乘百位和十位乘十位的结果均放置在答案数组的百位位置。</p><p><a href="https://www.luogu.com.cn/problem/P1303">原题链接</a></p><hr><h2 id="二、B进制星球"><a href="#二、B进制星球" class="headerlink" title="二、B进制星球"></a>二、B进制星球</h2><p><img src="https://img-blog.csdnimg.cn/20200824214721153.png" alt="B进制星球"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10000100;int A[N], B[N], C[N];int main()&#123;    int n;    string a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    int x &#x3D; a.length(), y &#x3D; b.length();    for(int i &#x3D; x; i &gt; 0; i --)     &#123;        if(n &gt;&#x3D; 10 &amp;&amp; a[x - i] &gt;&#x3D; &#39;A&#39;) A[i] &#x3D; (a[x - i] - &#39;A&#39; + 10);        else    A[i] &#x3D; (a[x - i] - &#39;0&#39;);    &#125;    for(int i &#x3D; y; i &gt; 0; i --)    &#123;        if(n &gt;&#x3D; 10 &amp;&amp; b[y - i] &gt;&#x3D; &#39;A&#39;) B[i] &#x3D; (b[y - i] - &#39;A&#39; + 10);        else    B[i] &#x3D; (b[y - i] - &#39;0&#39;);    &#125;    for(int i &#x3D; 1 ; i &lt;&#x3D; x || i &lt;&#x3D; y; i ++)&#x2F;&#x2F;相加    &#123;        C[i] &#x3D; A[i] + B[i];    &#125;    &#x2F;&#x2F;进位    int l &#x3D; x + y;    int t &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; l; i ++)    &#123;        C[i] +&#x3D; t;        t &#x3D; C[i] &#x2F; n;        C[i] %&#x3D; n;    &#125;    while(C[l] &#x3D;&#x3D; 0 &amp;&amp; l &gt; 0) l --;    for(int i &#x3D; l; i &gt; 0; i --)    &#123;        if(C[i] &lt; 10)   cout &lt;&lt; C[i];        else         &#123;            cout &lt;&lt; char(&#39;A&#39; + C[i] - 10);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题和普通的高精度题目相比有两点需要注意的<br>①当输入进制数的时候，需要对进制数进行判断，是否为十进制以上的进制，并且输入的字母要转换成相对应的数字</p><p>②在最后进位的时候，进位的数值要以输入的B进制为准，并且结果输出时也需要进行字母的转换。</p><p><a href="https://www.luogu.com.cn/problem/P1604">原题链接</a></p><hr><p>高精度基础解题思路<br>①大整数存储<br>先用string类型存储我们所需要进行计算的大整数<br>再依次将每一位存入数组当中，需要注意的是，在数组中从小到大依次从大整数的低位开始进行存储</p><p>②将大整数所对应的数组拿来进行相应的加减乘除运算<br>（依据竖式加减乘除法则）</p><p>③将所得的结果存储进另一个空数组，并对每一位是否需要进位的查询操作</p><p>④将进位之后的结果数组依次高位向地位输出。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 高精度</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>我们这里所表示的高精度，大部分都是将大整数存储在数组中，来通过加减乘除基本运算法则，来对数组中的每一位数字来进行加减乘除，从而达到大整数加减乘除的目的。</p><h1 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h1><h2 id="一、高精度加法"><a href="#一、高精度加法" class="headerlink" title="一、高精度加法"></a>一、高精度加法</h2><p>输入：两个大整数     输出：大整数相加的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector &lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t +&#x3D; A[i];        if(i &lt; B.size())    t +&#x3D; B[i];        C.push_back(t % 10);        t &#x2F;&#x3D; 10;     &#125;    if(t)   C.push_back(t);    return C;&#125;int main()&#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --)    A.push_back(a[i] - &#39;0&#39;);    for(int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i --)    B.push_back(b[i] - &#39;0&#39;);    auto C &#x3D; add(A, B) ;    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题同时通过vector容器，节省了空间</p><hr><h2 id="二、高精度减法"><a href="#二、高精度减法" class="headerlink" title="二、高精度减法"></a>二、高精度减法</h2><p>输入：两个大整数，大小顺序无要求    输出：第一个数减去第二个数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if (A.size() !&#x3D; B.size()) return A.size() &gt; B.size();    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )        if (A[i] !&#x3D; B[i])            return A[i] &gt; B[i];    return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t &#x3D; A[i] - t;        if (i &lt; B.size()) t -&#x3D; B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t &#x3D; 1;        else t &#x3D; 0;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i -- ) A.push_back(a[i] - &#39;0&#39;);    for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i -- ) B.push_back(b[i] - &#39;0&#39;);    vector&lt;int&gt; C;    if (cmp(A, B)) C &#x3D; sub(A, B);    else C &#x3D; sub(B, A), cout &lt;&lt; &#39;-&#39;;    for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i -- ) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题的思路和大整数加法类似，唯一需要注意的是，当二者大小顺序相反时，即应当输出负数时，应该进行判断。 A-B &lt; 0, -(B-A)就是结果</p><hr><h2 id="三、高精度乘法"><a href="#三、高精度乘法" class="headerlink" title="三、高精度乘法"></a>三、高精度乘法</h2><p>输入：一个大整数和一个小整数    输出：两数相乘的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0; i &lt; A.size(); i ++)    &#123;        if(i &lt; A.size()) t +&#x3D; A[i] * b;        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    if(t !&#x3D; 0)   C.push_back(t);    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    int b;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C &#x3D; mul(A, b);    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头用string存储大整数，用小整数来乘以大整数的每一位，然后根据所占的位数来进行进位。</p><hr><h2 id="四、高精度除法"><a href="#四、高精度除法" class="headerlink" title="四、高精度除法"></a>四、高精度除法</h2><p>输入：除数 被除数（不为0）    输出：除数除以被除数的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r &#x3D; 0;    for(int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i --)    &#123;        r &#x3D; r * 10 + A[i];&#x2F;&#x2F;借位        C.push_back(r &#x2F; b);        r &#x3D; r % b;    &#125;    reverse(C.begin(), C.end());    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    int b, r;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C &#x3D; div(A, b, r);    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面比较重要的是对于“借位”思想的代码操作，值得仔细琢磨</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练  归并排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>在学习了快排和归并排序的模板之后，快排在我们的题目中基本是不会出现的，出现的一般都是归并排序，在这里我记录几个训练过觉得比较有意义的归并排序的题目（题目均源自：洛谷）</p><hr><h1 id="归并排序题目"><a href="#归并排序题目" class="headerlink" title="归并排序题目"></a>归并排序题目</h1><h2 id="一、最接近神的人"><a href="#一、最接近神的人" class="headerlink" title="一、最接近神的人"></a>一、最接近神的人</h2><p><a href="https://www.luogu.com.cn/problem/P1774">原题链接</a></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 500050;int q[N], p[N];long long sum;void sort(int q[], int l, int r)&#123;    if(l &gt;&#x3D; r)  return;    int mid &#x3D; (l + r) &#x2F; 2;    sort(q, l, mid), sort(q, mid + 1, r);    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if(q[i] &lt;&#x3D; q[j])        &#123;            p[k ++] &#x3D; q[i ++];        &#125;        else        &#123;            p[k ++] &#x3D; q[j ++];            sum +&#x3D; mid - i + 1;&#x2F;&#x2F;核心        &#125;    &#125;    while(i &lt;&#x3D; mid) p[k ++] &#x3D; q[i ++];    while(j &lt;&#x3D; r)   p[k ++] &#x3D; q[j ++];    for(i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++)   q[i] &#x3D; p[j];&#125;int main()&#123;    int n;    cin &gt;&gt; n;    for(int i &#x3D; 0; i &lt; n; i ++) cin &gt;&gt; q[i];    sort(q, 0, n - 1);    cout &lt;&lt; sum;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题在归并排序的条件之下，进行了一些更为基本的调整，在进行大小顺序相反的交换时，会进行操作sum += mid - i + 1，这是本题的核心语句，仅当大小顺序相反时进行语句。</p><hr><h2 id="二、瑞士轮"><a href="#二、瑞士轮" class="headerlink" title="二、瑞士轮"></a>二、瑞士轮</h2><p><a href="https://www.luogu.com.cn/problem/P1309">原题链接</a></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;const int N &#x3D; 200100;int p[N], q[N], a[N];&#x2F;&#x2F;p存放能力值 q存放分数 a存放排名int w[N], l[N];&#x2F;&#x2F;w数组存放赢的人的序号 l数组存放输的人的序号bool op(int x, int y)&#123;    if(q[x] &#x3D;&#x3D; q[y])    return x &lt; y;    return q[x] &gt; q[y];&#125;int main()&#123;    int n, r, t;    &#x2F;&#x2F;2*n是总选手数目 r是比赛轮次 q是关注的排名    cin &gt;&gt; n &gt;&gt; r &gt;&gt; t;    n *&#x3D; 2;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        a[i] &#x3D; i;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        cin &gt;&gt; q[i];    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        cin &gt;&gt; p[i] ;    &#125;    sort(a + 1, a + n + 1, op);&#x2F;&#x2F;先将分数进行排列    &#x2F;&#x2F;a[1]-a[n] 的数值按照op进行排序    for(int i &#x3D; 1; i &lt;&#x3D; r; i ++)    &#123;        int b &#x3D; 0;        for(int j &#x3D; 1; j &lt;&#x3D; n; j +&#x3D; 2)        &#123;            if(p[a[j]] &gt;&#x3D; p[a[j + 1]])&#x2F;&#x2F;根据能力值来判断胜负            &#123;                q[a[j]] ++;                w[++ b] &#x3D; a[j];                l[b] &#x3D; a[j + 1];&#x2F;&#x2F;记录胜者组记号和相对应的排名            &#125;            else            &#123;                q[a[j + 1]] ++;                w[++ b] &#x3D; a[j + 1];                l[b] &#x3D; a[j];            &#125;        &#125;        int x &#x3D; 1, y &#x3D; 1, k &#x3D; 1;        while(x &lt;&#x3D; b &amp;&amp; y &lt;&#x3D; b)        &#123;            if(op(w[x], l[y]))            &#123;                a[k ++] &#x3D; w[x ++];            &#125;            else            &#123;                a[k ++] &#x3D; l[y ++];            &#125;        &#125;        while (x &lt;&#x3D; b)        &#123;            a[k ++] &#x3D; w[x ++];        &#125;        while (y &lt;&#x3D; b)           &#123;            a[k ++] &#x3D; l[y ++];        &#125;    &#125;    cout &lt;&lt; a[t];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目需要开的数据比较多，但是题目里面的主体内容还是归并排序。只是在归并排序里面添加了两组，分为胜者组和败者组。</p><p>每组比赛的胜者：赛前，总分是按降序排的；获胜后都得1分，仍是降序；</p><p>每组比赛的负者：赛前，总分是按降序排的；不得分，仍是降序。</p><p>先按初始分数排序，然后按分数高低两人一组比赛；</p><p>胜者入队A，负者入队B。这样A、B自身仍是有序的；</p><p>只需进行合并操作即可，合并操作的复杂度是O(n),而如果用快排其复杂度为O(nlogn)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法  排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>虽然在C++里面有他自己所对应的sort函数，可以非常方便的来进行数组的排序，但是可以手写一个排序也是我们所必须要掌握的，这里介绍快速排序和归并排序两种排序</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>下面我们介绍两种排序方式</p><h2 id="一、快速排序"><a href="#一、快速排序" class="headerlink" title="一、快速排序"></a>一、快速排序</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N];void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);&#x2F;&#x2F;当找到比x小的停下        do j -- ; while (q[j] &gt; x);&#x2F;&#x2F;当找到比x大的停下        if (i &lt; j) swap(q[i], q[j]);&#x2F;&#x2F;两数交换    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1, r);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    quick_sort(q, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本段代码通过多次将数组分为两份，来实现排序。</p><hr><h2 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N], p[N];int n;void msort(int l, int r)&#123;    if(l &gt;&#x3D; r)  return;    int mid &#x3D; (l + r) &#x2F; 2;    msort(l, mid), msort(mid + 1, r);&#x2F;&#x2F;分割成多个小的数组    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 1;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if(q[i] &lt;&#x3D; q[j])    p[k ++] &#x3D; q[i ++];&#x2F;&#x2F;比较大小        if(q[i] &gt; q[j])     p[k ++] &#x3D; q[j ++];    &#125;    while(i &lt;&#x3D; mid) p[k ++] &#x3D; q[i ++];&#x2F;&#x2F;将没有塞进p数组的数字依次“丢进去”    while(j &lt;&#x3D; r)   p[k ++] &#x3D; q[j ++];    for(int i &#x3D; l, j &#x3D; 1; i &lt;&#x3D; r;)  q[i ++] &#x3D; p[j ++];&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    msort(1, n);    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cout &lt;&lt; q[i] &lt;&lt; &#39; &#39;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先递归依次将数组分为多个小数组，然后对于每个小数组来进行比较操作，并用一个p数组来存储结果，最后将p数组的值赋值给q数组来达到排序的目的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在我们写博客的过程中，熟练掌握markdown语法，常常会使得自己的办事效率有事半功倍的效果，所以掌握markdown语法，是我们写博客的第一步，也是最基础重要的一步。</p><h1 id="Markdown快速入门（typora）"><a href="#Markdown快速入门（typora）" class="headerlink" title="Markdown快速入门（typora）"></a>Markdown快速入门（typora）</h1><h2 id="1-代码块："><a href="#1-代码块：" class="headerlink" title="1.代码块："></a>1.代码块：</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 用&#96;&#96;&#96; + 自己的语言再回车即可&#x2F;&#x2F; C++ 代码块 ： &#96;&#96;&#96;C++ 以此类推<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"># 标题名称## 标题名称### 标题名称#### 标题名称##### 标题名称###### 标题名称从上到下 从一级标题到六级标题 从大到小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="标题名称"><a href="#标题名称" class="headerlink" title="标题名称"></a>标题名称</h1><h2 id="标题名称-1"><a href="#标题名称-1" class="headerlink" title="标题名称"></a>标题名称</h2><h3 id="标题名称-2"><a href="#标题名称-2" class="headerlink" title="标题名称"></a>标题名称</h3><h4 id="标题名称-3"><a href="#标题名称-3" class="headerlink" title="标题名称"></a>标题名称</h4><h5 id="标题名称-4"><a href="#标题名称-4" class="headerlink" title="标题名称"></a>标题名称</h5><h6 id="标题名称-5"><a href="#标题名称-5" class="headerlink" title="标题名称"></a>标题名称</h6><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 加粗**加粗语言**&#x2F;&#x2F; 删除线~~删除线内容~~&#x2F;&#x2F; 斜体*斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加粗语言</strong></p><p><del>删除线内容</del></p><p><em>斜体内容</em></p><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 引用语法&gt;作者：xxx&gt;&gt;作者：xxx&gt;&gt;&gt;作者：xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p></blockquote></blockquote></blockquote><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;分割线---&#x2F;&#x2F;分割线2***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;在线图片&#x2F;本地图片！[图片的名字](地址) ----本地即为文件地址，在线即为右键图片链接（有网络)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7. 超链接"></a>7. 超链接</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;超链接语法[名字](具体地址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://wustuzi.github.io/">我的github</a></p><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;无序列表- 目录一- 目录二&#x2F;&#x2F;有序表格1 + 。 + 空格1.xxx2.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>目录一</li><li>目录二</li></ul><p>​    1.xxx</p><p>​    2.xxx</p><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>右键插入即可</p><table><thead><tr><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><pre class="line-numbers language-？C++" data-language="？C++"><code class="language-？C++">按住ctrl + &#x2F; 查看源码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/21/hello-world/"/>
      <url>/2020/08/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
