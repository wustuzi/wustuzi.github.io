<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法训练 二分</title>
      <link href="/2020/08/25/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%BA%8C%E5%88%86/"/>
      <url>/2020/08/25/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>在基本掌握了二分的概念之后，如何在题目中，对应不同的题目，灵活使用，灵活改变while里面if的形式，是我们灵活解决二分题目的关键</p><h1 id="算法训练-二分"><a href="#算法训练-二分" class="headerlink" title="算法训练 二分"></a>算法训练 二分</h1><h2 id="一、砍树"><a href="#一、砍树" class="headerlink" title="一、砍树"></a>一、砍树</h2><p><img src="https://img-blog.csdnimg.cn/20200825214819393.png" alt="砍树"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1000010;int q[N];int n;long long m;bool check(int x)&#x2F;&#x2F;判断if里面的东西 在这个x答案的时候是否符合题目要求 以此来缩小区间&#123;    long long sum &#x3D; 0;    for(int i &#x3D; n; q[i] &gt; x &amp;&amp; i &gt;&#x3D; 1; i --)    sum +&#x3D; q[i] - x;    if(sum &gt;&#x3D; m) return true;    else return false;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    sort(q + 1, q + 1 + n);    int l &#x3D; 0, r &#x3D; q[n], mid;    while(l &lt; r)    &#123;        mid &#x3D; (l + r + 1) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    cout &lt;&lt; r;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题应该算是二分当中比较基础的一道题目，非常简单，我们二分的目标主要就是答案，我们需要砍树的高度就是我们需要去求得的结果，然而这个结果有一个区间，区间显然是0 ——这群树的最高高度。<br>然后通过二分答案区间组来快速求得答案。</p><p><a href="https://www.luogu.com.cn/problem/P1873">原题链接</a></p><hr><h2 id="二、数列分段-Section-II"><a href="#二、数列分段-Section-II" class="headerlink" title="二、数列分段 Section II"></a>二、数列分段 Section II</h2><p><img src="https://img-blog.csdnimg.cn/20200825214908401.png" alt="数列分段 Section II"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1000100;int m, n;int q[N];bool check(long long x)&#x2F;&#x2F;x的意思代表一组和最大为x&#123;    int s &#x3D; 0, num &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        if(s + q[i] &gt; x )           &#123;            num ++, s &#x3D; 0;        &#125;        s +&#x3D; q[i];        if(num &gt;&#x3D; m) return false;&#x2F;&#x2F;当组数超过题目条件时，失败    &#125;    return true;&#x2F;&#x2F;当运行到这里还没有return false时即表示该答案区间可以&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    long long sum &#x3D; 0, max &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        sum +&#x3D; q[i];        if(max &lt;&#x3D; q[i]) max &#x3D; q[i];    &#125;    long long l &#x3D; max, r &#x3D; sum, mid;&#x2F;&#x2F;最小的一组是最大的单个数，最大的是全部一组    while(l &lt; r)    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    cout &lt;&lt; l;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目很有意思，我们二分的是我们所需要的答案，但是我们需要将我们求得答案的区间进行压缩，右区间显然是全部数值相加的和，左区间应该是我们的全部数组中每个元素的最大值.然后通过二分求得该答案是否可行。二分的时候在check函数里面，我们可以定义一个数，来对每一个已经达到我们测试的值进行分装。</p><p><a href="https://www.luogu.com.cn/problem/P1182">原题链接</a></p><hr><h2 id="三、切绳子"><a href="#三、切绳子" class="headerlink" title="三、切绳子"></a>三、切绳子</h2><p><img src="https://img-blog.csdnimg.cn/20200825214928931.png" alt="切绳子"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;const int N &#x3D; 10010;int n, k;float q[N];bool check(float x)&#123;    int num &#x3D; 0;    float a;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        a &#x3D; q[i];         while(a - x &gt; 0)        &#123;            num ++;            a -&#x3D; x;        &#125;        if(num &gt;&#x3D; k)    return true;总长度大于等于所需长度    &#125;    return false;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    sort(q + 1, q + n + 1);    float l &#x3D; 0.01, r &#x3D; q[n], mid;    while(r - l &gt; 0.01)&#x2F;&#x2F;当所取区间小于一个数字时即停止    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else    r &#x3D; mid - 0.01;    &#125;    printf(&quot;%.2f&quot;, l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题需要灵活运用的地方很多，可以仔细理解。</p><hr><h2 id="四、进击的奶牛"><a href="#四、进击的奶牛" class="headerlink" title="四、进击的奶牛"></a>四、进击的奶牛</h2><p><img src="https://img-blog.csdnimg.cn/20200825214841822.png" alt="进击的奶牛"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int A[1000010];int a, n, c;bool check(int m)&#123;    int num &#x3D; 0;    int x &#x3D; A[1];&#x2F;&#x2F;第一只牛的储存位置    for(int i &#x3D; 2; i &lt;&#x3D; n; i ++)    &#123;        if(A[i] - x &lt; m)   num ++;        else    x &#x3D; A[i];&#x2F;&#x2F;变成“第一只牛”        if(num &gt; a) return false;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; c;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; A[i];    sort(A + 1, A + n + 1);    a &#x3D; n - c;    int l &#x3D; 1, r &#x3D; A[n] - A[1], mid;&#x2F;&#x2F;最小的时候距离为1 最大的时候只有两只牛    while(l + 1 &lt; r)    &#123;        mid &#x3D; (l + r) &#x2F; 2;        if(check(mid))  l &#x3D; mid;        else    r &#x3D; mid;    &#125;    if(check(r)) cout &lt;&lt; r;    else cout &lt;&lt; l;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目也是和之前的题目一样，通过筛选答案的区间，从而得到题解，这个题题目很巧妙，通过放牛进坑的方式来得到这道题最终的答案。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 二分</title>
      <link href="/2020/08/25/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"/>
      <url>/2020/08/25/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>二分是我们在解题时候常用的一种可以对有序的数列进行快速查找的一种方法，熟练灵活运用二分模板，可以在一些特定时候极大加快运行速度。</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a>一、查找</h2><p><img src="https://img-blog.csdnimg.cn/2020082512430149.png" alt="查找"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int n, m, p;int q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)    cin &gt;&gt; q[i];    while(m --)    &#123;        int l &#x3D; 1, r &#x3D; n;        cin &gt;&gt; p;        while(l + 1 &lt; r)        &#123;            int mid &#x3D; (l + r) &#x2F; 2;            if(q[mid] &lt; p) l &#x3D; mid + 1;            else    r &#x3D; mid;        &#125;        if(q[l] &#x3D;&#x3D; p)   cout &lt;&lt; l;        else if(q[r] &#x3D;&#x3D; p)  cout &lt;&lt; r;        else    cout &lt;&lt; &quot;-1&quot;;        cout &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目是一个很基本的二分题目，可见二分的基本模板应该是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(l + 1 &lt; r)&#123;      int mid &#x3D; (l + r) &#x2F; 2;    if(q[mid] &lt; p) l &#x3D; mid + 1;    else    r &#x3D; mid;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过while内部if的条件来更改所需要的区间而达到一次筛选一半的目的，当左右两区间相等时，所得到的最小区间即应该是我们所寻找的答案，当然如果这个区间里面也不含答案的话，则说明答案不存在。</p><hr><h2 id="二、一元三次方程的解"><a href="#二、一元三次方程的解" class="headerlink" title="二、一元三次方程的解"></a>二、一元三次方程的解</h2><p><img src="https://img-blog.csdnimg.cn/20200825125059362.png" alt="一元三次方程的解"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;float a, b, c, d, mid;float res(float x)&#x2F;&#x2F;&#123;    float q;    q &#x3D; a * x * x * x + b * x * x + c * x + d;    return q;&#125;int main()&#123;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;    for(float l &#x3D; -100; l &lt;&#x3D; 99; l ++)    &#123;        float r &#x3D; l + 1;        if(res(l) * res(r) &lt;&#x3D; 0)        &#123;            while(r - l &gt; 0.00001)            &#123;                mid &#x3D; (l + r) &#x2F; 2;                if(res(l) * res(mid) &gt; 0)  l &#x3D; mid;                else    r &#x3D; mid;            &#125;            if(res(mid) &lt; 0.1)            &#123;            printf(&quot;%.2f &quot;, mid);            &#125;         &#125;        else    continue;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题也应该算是比较经典的一道题目，我们需要通过二分定义答案区间，这个题需要注意的是二分时while循环的条件，while里面的条件是处理浮点数二分的不一样的地方。</p><hr><p>二分的基本概念就是把有序列答案区间进行中点的分割，根据某项性质求出答案存在的那一边，经过多次二分最终将答案所属区间确定为一个点。<br>二分较难的地方在于对于某些情况，mid = （l + r + 1）/ 2；<br>这里推荐一种比较好的办法，将二分的条件最后转化成while（l + 1 &lt; r）这样可以有效的避免死循环<br>但是需要注意的是<br>在下面输出结果的时候 必须要对l和r分别都进行答案检验。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练 高精度</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2020/08/24/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>高精度里面，最根本的就是学会用数组来存储数据，灵活运用数组，将可以很好的掌握所有类型的高精度题目</p><h1 id="算法训练-高精度"><a href="#算法训练-高精度" class="headerlink" title="算法训练 高精度"></a>算法训练 高精度</h1><h2 id="一、高精度乘法（两个大整数）"><a href="#一、高精度乘法（两个大整数）" class="headerlink" title="一、高精度乘法（两个大整数）"></a>一、高精度乘法（两个大整数）</h2><p><img src="https://img-blog.csdnimg.cn/20200824214321829.png" alt="高精度乘法"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10000010;int A[N], B[N], C[N];int main()&#123;    string a, b;    cin &gt;&gt; a &gt;&gt; b;    int x &#x3D; a.length(), y &#x3D; b.length();    for(int i &#x3D; x; i &gt; 0; i --) A[i] &#x3D; (a[x - i] - &#39;0&#39;);    for(int i &#x3D; y; i &gt; 0; i --) B[i] &#x3D; (b[y - i] - &#39;0&#39;);    for(int i &#x3D; 1; i &lt;&#x3D; x; i ++)    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; y; j ++)        &#123;            C[i + j - 1] +&#x3D; A[i] * B[j];        &#125;    &#125;    int l &#x3D; x + y;    int t &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; l; i ++)    &#123;        C[i] +&#x3D; t;        t &#x3D; C[i] &#x2F; 10;        C[i] %&#x3D; 10;    &#125;    int k;    while(C[l] &#x3D;&#x3D; 0 &amp;&amp; l &gt; 1) l --;    for(int i &#x3D; l; l &gt; 0; l --)    cout &lt;&lt; C[l];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乘法题目需要注意的是每几位相乘的结果所在的位，比如个位乘百位和十位乘十位的结果均放置在答案数组的百位位置。</p><p><a href="https://www.luogu.com.cn/problem/P1303">原题链接</a></p><hr><h2 id="二、B进制星球"><a href="#二、B进制星球" class="headerlink" title="二、B进制星球"></a>二、B进制星球</h2><p><img src="https://img-blog.csdnimg.cn/20200824214721153.png" alt="B进制星球"></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 10000100;int A[N], B[N], C[N];int main()&#123;    int n;    string a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    int x &#x3D; a.length(), y &#x3D; b.length();    for(int i &#x3D; x; i &gt; 0; i --)     &#123;        if(n &gt;&#x3D; 10 &amp;&amp; a[x - i] &gt;&#x3D; &#39;A&#39;) A[i] &#x3D; (a[x - i] - &#39;A&#39; + 10);        else    A[i] &#x3D; (a[x - i] - &#39;0&#39;);    &#125;    for(int i &#x3D; y; i &gt; 0; i --)    &#123;        if(n &gt;&#x3D; 10 &amp;&amp; b[y - i] &gt;&#x3D; &#39;A&#39;) B[i] &#x3D; (b[y - i] - &#39;A&#39; + 10);        else    B[i] &#x3D; (b[y - i] - &#39;0&#39;);    &#125;    for(int i &#x3D; 1 ; i &lt;&#x3D; x || i &lt;&#x3D; y; i ++)&#x2F;&#x2F;相加    &#123;        C[i] &#x3D; A[i] + B[i];    &#125;    &#x2F;&#x2F;进位    int l &#x3D; x + y;    int t &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; l; i ++)    &#123;        C[i] +&#x3D; t;        t &#x3D; C[i] &#x2F; n;        C[i] %&#x3D; n;    &#125;    while(C[l] &#x3D;&#x3D; 0 &amp;&amp; l &gt; 0) l --;    for(int i &#x3D; l; i &gt; 0; i --)    &#123;        if(C[i] &lt; 10)   cout &lt;&lt; C[i];        else         &#123;            cout &lt;&lt; char(&#39;A&#39; + C[i] - 10);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题和普通的高精度题目相比有两点需要注意的<br>①当输入进制数的时候，需要对进制数进行判断，是否为十进制以上的进制，并且输入的字母要转换成相对应的数字</p><p>②在最后进位的时候，进位的数值要以输入的B进制为准，并且结果输出时也需要进行字母的转换。</p><p><a href="https://www.luogu.com.cn/problem/P1604">原题链接</a></p><hr><p>高精度基础解题思路<br>①大整数存储<br>先用string类型存储我们所需要进行计算的大整数<br>再依次将每一位存入数组当中，需要注意的是，在数组中从小到大依次从大整数的低位开始进行存储</p><p>②将大整数所对应的数组拿来进行相应的加减乘除运算<br>（依据竖式加减乘除法则）</p><p>③将所得的结果存储进另一个空数组，并对每一位是否需要进位的查询操作</p><p>④将进位之后的结果数组依次高位向地位输出。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 高精度</title>
      <link href="/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2020/08/24/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>我们这里所表示的高精度，大部分都是将大整数存储在数组中，来通过加减乘除基本运算法则，来对数组中的每一位数字来进行加减乘除，从而达到大整数加减乘除的目的。</p><h1 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h1><h2 id="一、高精度加法"><a href="#一、高精度加法" class="headerlink" title="一、高精度加法"></a>一、高精度加法</h2><p>输入：两个大整数     输出：大整数相加的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector &lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t +&#x3D; A[i];        if(i &lt; B.size())    t +&#x3D; B[i];        C.push_back(t % 10);        t &#x2F;&#x3D; 10;     &#125;    if(t)   C.push_back(t);    return C;&#125;int main()&#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --)    A.push_back(a[i] - &#39;0&#39;);    for(int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i --)    B.push_back(b[i] - &#39;0&#39;);    auto C &#x3D; add(A, B) ;    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题同时通过vector容器，节省了空间</p><hr><h2 id="二、高精度减法"><a href="#二、高精度减法" class="headerlink" title="二、高精度减法"></a>二、高精度减法</h2><p>输入：两个大整数，大小顺序无要求    输出：第一个数减去第二个数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if (A.size() !&#x3D; B.size()) return A.size() &gt; B.size();    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )        if (A[i] !&#x3D; B[i])            return A[i] &gt; B[i];    return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t &#x3D; A[i] - t;        if (i &lt; B.size()) t -&#x3D; B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t &#x3D; 1;        else t &#x3D; 0;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i -- ) A.push_back(a[i] - &#39;0&#39;);    for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i -- ) B.push_back(b[i] - &#39;0&#39;);    vector&lt;int&gt; C;    if (cmp(A, B)) C &#x3D; sub(A, B);    else C &#x3D; sub(B, A), cout &lt;&lt; &#39;-&#39;;    for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i -- ) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题的思路和大整数加法类似，唯一需要注意的是，当二者大小顺序相反时，即应当输出负数时，应该进行判断。 A-B &lt; 0, -(B-A)就是结果</p><hr><h2 id="三、高精度乘法"><a href="#三、高精度乘法" class="headerlink" title="三、高精度乘法"></a>三、高精度乘法</h2><p>输入：一个大整数和一个小整数    输出：两数相乘的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0; i &lt; A.size(); i ++)    &#123;        if(i &lt; A.size()) t +&#x3D; A[i] * b;        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    if(t !&#x3D; 0)   C.push_back(t);    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    int b;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C &#x3D; mul(A, b);    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头用string存储大整数，用小整数来乘以大整数的每一位，然后根据所占的位数来进行进位。</p><hr><h2 id="四、高精度除法"><a href="#四、高精度除法" class="headerlink" title="四、高精度除法"></a>四、高精度除法</h2><p>输入：除数 被除数（不为0）    输出：除数除以被除数的结果</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r &#x3D; 0;    for(int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i --)    &#123;        r &#x3D; r * 10 + A[i];&#x2F;&#x2F;借位        C.push_back(r &#x2F; b);        r &#x3D; r % b;    &#125;    reverse(C.begin(), C.end());    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    int b, r;    string a;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(a[i] - &#39;0&#39;);    auto C &#x3D; div(A, b, r);    for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i --) cout &lt;&lt; C[i];    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面比较重要的是对于“借位”思想的代码操作，值得仔细琢磨</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练  归并排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>在学习了快排和归并排序的模板之后，快排在我们的题目中基本是不会出现的，出现的一般都是归并排序，在这里我记录几个训练过觉得比较有意义的归并排序的题目（题目均源自：洛谷）</p><hr><h1 id="归并排序题目"><a href="#归并排序题目" class="headerlink" title="归并排序题目"></a>归并排序题目</h1><h2 id="一、最接近神的人"><a href="#一、最接近神的人" class="headerlink" title="一、最接近神的人"></a>一、最接近神的人</h2><p><a href="https://www.luogu.com.cn/problem/P1774">原题链接</a></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 500050;int q[N], p[N];long long sum;void sort(int q[], int l, int r)&#123;    if(l &gt;&#x3D; r)  return;    int mid &#x3D; (l + r) &#x2F; 2;    sort(q, l, mid), sort(q, mid + 1, r);    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if(q[i] &lt;&#x3D; q[j])        &#123;            p[k ++] &#x3D; q[i ++];        &#125;        else        &#123;            p[k ++] &#x3D; q[j ++];            sum +&#x3D; mid - i + 1;&#x2F;&#x2F;核心        &#125;    &#125;    while(i &lt;&#x3D; mid) p[k ++] &#x3D; q[i ++];    while(j &lt;&#x3D; r)   p[k ++] &#x3D; q[j ++];    for(i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++)   q[i] &#x3D; p[j];&#125;int main()&#123;    int n;    cin &gt;&gt; n;    for(int i &#x3D; 0; i &lt; n; i ++) cin &gt;&gt; q[i];    sort(q, 0, n - 1);    cout &lt;&lt; sum;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题在归并排序的条件之下，进行了一些更为基本的调整，在进行大小顺序相反的交换时，会进行操作sum += mid - i + 1，这是本题的核心语句，仅当大小顺序相反时进行语句。</p><hr><h2 id="二、瑞士轮"><a href="#二、瑞士轮" class="headerlink" title="二、瑞士轮"></a>二、瑞士轮</h2><p><a href="https://www.luogu.com.cn/problem/P1309">原题链接</a></p><p>题解：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;const int N &#x3D; 200100;int p[N], q[N], a[N];&#x2F;&#x2F;p存放能力值 q存放分数 a存放排名int w[N], l[N];&#x2F;&#x2F;w数组存放赢的人的序号 l数组存放输的人的序号bool op(int x, int y)&#123;    if(q[x] &#x3D;&#x3D; q[y])    return x &lt; y;    return q[x] &gt; q[y];&#125;int main()&#123;    int n, r, t;    &#x2F;&#x2F;2*n是总选手数目 r是比赛轮次 q是关注的排名    cin &gt;&gt; n &gt;&gt; r &gt;&gt; t;    n *&#x3D; 2;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        a[i] &#x3D; i;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        cin &gt;&gt; q[i];    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)        &#123;        cin &gt;&gt; p[i] ;    &#125;    sort(a + 1, a + n + 1, op);&#x2F;&#x2F;先将分数进行排列    &#x2F;&#x2F;a[1]-a[n] 的数值按照op进行排序    for(int i &#x3D; 1; i &lt;&#x3D; r; i ++)    &#123;        int b &#x3D; 0;        for(int j &#x3D; 1; j &lt;&#x3D; n; j +&#x3D; 2)        &#123;            if(p[a[j]] &gt;&#x3D; p[a[j + 1]])&#x2F;&#x2F;根据能力值来判断胜负            &#123;                q[a[j]] ++;                w[++ b] &#x3D; a[j];                l[b] &#x3D; a[j + 1];&#x2F;&#x2F;记录胜者组记号和相对应的排名            &#125;            else            &#123;                q[a[j + 1]] ++;                w[++ b] &#x3D; a[j + 1];                l[b] &#x3D; a[j];            &#125;        &#125;        int x &#x3D; 1, y &#x3D; 1, k &#x3D; 1;        while(x &lt;&#x3D; b &amp;&amp; y &lt;&#x3D; b)        &#123;            if(op(w[x], l[y]))            &#123;                a[k ++] &#x3D; w[x ++];            &#125;            else            &#123;                a[k ++] &#x3D; l[y ++];            &#125;        &#125;        while (x &lt;&#x3D; b)        &#123;            a[k ++] &#x3D; w[x ++];        &#125;        while (y &lt;&#x3D; b)           &#123;            a[k ++] &#x3D; l[y ++];        &#125;    &#125;    cout &lt;&lt; a[t];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个题目需要开的数据比较多，但是题目里面的主体内容还是归并排序。只是在归并排序里面添加了两组，分为胜者组和败者组。</p><p>每组比赛的胜者：赛前，总分是按降序排的；获胜后都得1分，仍是降序；</p><p>每组比赛的负者：赛前，总分是按降序排的；不得分，仍是降序。</p><p>先按初始分数排序，然后按分数高低两人一组比赛；</p><p>胜者入队A，负者入队B。这样A、B自身仍是有序的；</p><p>只需进行合并操作即可，合并操作的复杂度是O(n),而如果用快排其复杂度为O(nlogn)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法  排序</title>
      <link href="/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/23/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>虽然在C++里面有他自己所对应的sort函数，可以非常方便的来进行数组的排序，但是可以手写一个排序也是我们所必须要掌握的，这里介绍快速排序和归并排序两种排序</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>下面我们介绍两种排序方式</p><h2 id="一、快速排序"><a href="#一、快速排序" class="headerlink" title="一、快速排序"></a>一、快速排序</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N];void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);&#x2F;&#x2F;当找到比x小的停下        do j -- ; while (q[j] &gt; x);&#x2F;&#x2F;当找到比x大的停下        if (i &lt; j) swap(q[i], q[j]);&#x2F;&#x2F;两数交换    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1, r);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    quick_sort(q, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本段代码通过多次将数组分为两份，来实现排序。</p><hr><h2 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N], p[N];int n;void msort(int l, int r)&#123;    if(l &gt;&#x3D; r)  return;    int mid &#x3D; (l + r) &#x2F; 2;    msort(l, mid), msort(mid + 1, r);&#x2F;&#x2F;分割成多个小的数组    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 1;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if(q[i] &lt;&#x3D; q[j])    p[k ++] &#x3D; q[i ++];&#x2F;&#x2F;比较大小        if(q[i] &gt; q[j])     p[k ++] &#x3D; q[j ++];    &#125;    while(i &lt;&#x3D; mid) p[k ++] &#x3D; q[i ++];&#x2F;&#x2F;将没有塞进p数组的数字依次“丢进去”    while(j &lt;&#x3D; r)   p[k ++] &#x3D; q[j ++];    for(int i &#x3D; l, j &#x3D; 1; i &lt;&#x3D; r;)  q[i ++] &#x3D; p[j ++];&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cin &gt;&gt; q[i];    msort(1, n);    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )   cout &lt;&lt; q[i] &lt;&lt; &#39; &#39;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先递归依次将数组分为多个小数组，然后对于每个小数组来进行比较操作，并用一个p数组来存储结果，最后将p数组的值赋值给q数组来达到排序的目的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/22/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在我们写博客的过程中，熟练掌握markdown语法，常常会使得自己的办事效率有事半功倍的效果，所以掌握markdown语法，是我们写博客的第一步，也是最基础重要的一步。</p><h1 id="Markdown快速入门（typora）"><a href="#Markdown快速入门（typora）" class="headerlink" title="Markdown快速入门（typora）"></a>Markdown快速入门（typora）</h1><h2 id="1-代码块："><a href="#1-代码块：" class="headerlink" title="1.代码块："></a>1.代码块：</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 用&#96;&#96;&#96; + 自己的语言再回车即可&#x2F;&#x2F; C++ 代码块 ： &#96;&#96;&#96;C++ 以此类推<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"># 标题名称## 标题名称### 标题名称#### 标题名称##### 标题名称###### 标题名称从上到下 从一级标题到六级标题 从大到小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="标题名称"><a href="#标题名称" class="headerlink" title="标题名称"></a>标题名称</h1><h2 id="标题名称-1"><a href="#标题名称-1" class="headerlink" title="标题名称"></a>标题名称</h2><h3 id="标题名称-2"><a href="#标题名称-2" class="headerlink" title="标题名称"></a>标题名称</h3><h4 id="标题名称-3"><a href="#标题名称-3" class="headerlink" title="标题名称"></a>标题名称</h4><h5 id="标题名称-4"><a href="#标题名称-4" class="headerlink" title="标题名称"></a>标题名称</h5><h6 id="标题名称-5"><a href="#标题名称-5" class="headerlink" title="标题名称"></a>标题名称</h6><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 加粗**加粗语言**&#x2F;&#x2F; 删除线~~删除线内容~~&#x2F;&#x2F; 斜体*斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加粗语言</strong></p><p><del>删除线内容</del></p><p><em>斜体内容</em></p><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 引用语法&gt;作者：xxx&gt;&gt;作者：xxx&gt;&gt;&gt;作者：xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p><blockquote><p>作者：xxx</p></blockquote></blockquote></blockquote><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;分割线---&#x2F;&#x2F;分割线2***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;在线图片&#x2F;本地图片！[图片的名字](地址) ----本地即为文件地址，在线即为右键图片链接（有网络)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7. 超链接"></a>7. 超链接</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;超链接语法[名字](具体地址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://wustuzi.github.io/">我的github</a></p><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;无序列表- 目录一- 目录二&#x2F;&#x2F;有序表格1 + 。 + 空格1.xxx2.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>目录一</li><li>目录二</li></ul><p>​    1.xxx</p><p>​    2.xxx</p><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>右键插入即可</p><table><thead><tr><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><pre class="line-numbers language-？C++" data-language="？C++"><code class="language-？C++">按住ctrl + &#x2F; 查看源码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/21/hello-world/"/>
      <url>/2020/08/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
